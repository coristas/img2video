#!/usr/bin/env python2

# All the images need to be consistent in their resolutions
# before encoding.

import optparse, os, sys, random, subprocess, tempfile, mad, fractions, shutil, re
import PIL.Image
import PIL.ImageOps

FRAMES_PER_SEC = 25
DEFAULT_OUTPUT_FILE = 'out.avi'

def process(pics, mp3, geom, outfile):
    frames = mp3_length(mp3) * FRAMES_PER_SEC
    if len(pics) > frames:
        raise RuntimeError('The number of pictures must not exceed '
                           'the target number of frames')
    startframe = 0
    picdir = tempfile.mkdtemp(prefix='img2video')
    try:
        create_images(pics, geom, frames, picdir)
        encode(mp3, outfile, picdir)
    finally:
        shutil.rmtree(picdir)

def mp3_length(mp3):
    return mad.MadFile(mp3).total_time() / 1000

def scaled_size(size, geom):
    aspect = fractions.Fraction(*size)
    wanted_aspect = fractions.Fraction(*geom)
    g_w, g_h = geom
    if aspect < wanted_aspect:
        return int(g_h * aspect), g_h
    if aspect > wanted_aspect:
        return g_w, int(g_w / aspect)
    return geom

def process_pic(src, target, geom):
    if geom is None:
        os.symlink(os.path.abspath(src), target)
        return
    print 'fitting %s to %s, saving to %s' % (src, geom, target)
    img = PIL.Image.open(src)
    newsize = scaled_size(img.size, geom)
    if newsize != img.size:
        img = img.resize(newsize, PIL.Image.BICUBIC)
        full = PIL.Image.new(img.mode, geom)
        w, h = geom
        scaled_w, scaled_h = newsize
        full.paste(img, ((w - scaled_w) / 2, (h - scaled_h) / 2))
        full.save(target)
    else:
        os.symlink(os.path.abspath(src), target)

def create_images(pics, geom, frames, picdir):
    framesperpic = fractions.Fraction(frames, len(pics))
    startframe = 0
    crntdir = os.getcwd()
    for pic in pics:
        frameiter = ('%s/frame%d.jpg' % (picdir, i)
                     for i in xrange(int(startframe),
                                     int(startframe + framesperpic)))
        framefile = frameiter.next()
        pic = process_pic(pic, framefile, geom)
        # repeat the frame as needed
        for fl in frameiter:
            os.symlink(framefile, fl)
        startframe += framesperpic

def encode(mp3, outfile, picdir):
    subprocess.call(["ffmpeg",
                     "-r", str(FRAMES_PER_SEC),
                     "-i", picdir + '/frame%d.jpg', "-i", mp3,
                     "-vcodec", "ffv1","-b", "500k", "-acodec","copy",
                     outfile])

GEOM_RE = re.compile(r'(\d+)x(\d+)$')

def parse_geometry(s):
    match = GEOM_RE.match(s)
    if not match:
        raise ValueError("invalid geometry %r" % s)
    return (int(match.group(1)), int(match.group(2)))

def main():
    parser = optparse.OptionParser(usage="%prog [-s] [o OUTFILE] MP3 IMAGE...")
    parser.add_option('-g', '--geom', dest='geom',
                      help='image geometry')
    parser.add_option('-s', '--shuffle', dest='shuffle',
                      default=False, action='store_true',
                      help='shuffle images before encoding')
    parser.add_option('-o', '--output', dest='output',
                      help='output file name, defaults to out.avi')
    options, args = parser.parse_args()
    if len(args) < 2:
        parser.print_usage(sys.stderr)
        sys.exit(2)
    mp3 = args[0]
    pics = args[1:]
    if options.shuffle:
        random.shuffle(pics)
    if options.geom:
        geom = parse_geometry(options.geom)
    else:
        geom = None
    process(pics, mp3, geom, options.output or DEFAULT_OUTPUT_FILE)

if __name__ == '__main__':
    main()
