#!/usr/bin/env python2

# All the images need to be consistent in their resolutions
# before encoding.

import optparse
import os, sys, re, itertools
import random, subprocess, shutil, tempfile
import mad
import fractions
import PIL.Image, PIL.ImageOps, PIL.ExifTags

FRAMES_PER_SEC = 25
DEFAULT_OUTPUT_FILE = 'out.avi'
DEFAULT_GEOMETRY = (640, 480)

def process(pics, mp3, geom, outfile):
    frames = mp3_length(mp3) * FRAMES_PER_SEC
    if len(pics) > frames:
        raise RuntimeError('The number of pictures must not exceed '
                           'the target number of frames')
    startframe = 0
    picdir = tempfile.mkdtemp(prefix='img2video')
    try:
        create_images(pics, geom, frames, picdir)
        encode(mp3, outfile, picdir)
    finally:
        print 'deleting', picdir
        shutil.rmtree(picdir)

def mp3_length(mp3):
    return mad.MadFile(mp3).total_time() / 1000

def get_tagid(name):
    for tagid, tagname in PIL.ExifTags.TAGS.iteritems():
        if tagname == name:
            return tagid

def get_tagval(img, tagname):
    return img._getexif().get(get_tagid(tagname))

transposition_map = {
    2: (PIL.Image.FLIP_LEFT_RIGHT,),
    3: (PIL.Image.ROTATE_180,),
    4: (PIL.Image.FLIP_TOP_BOTTOM,),
    5: (PIL.Image.FLIP_TOP_BOTTOM, PIL.Image.ROTATE_270),
    6: (PIL.Image.ROTATE_270,),
    7: (PIL.Image.FLIP_LEFT_RIGHT, PIL.Image.ROTATE_270),
    8: (PIL.Image.ROTATE_90,),
}

def apply_exif_orientation(img):
    orient = get_tagval(img, 'Orientation')
    for method in transposition_map.get(orient, ()):
        img = img.transpose(method)
    return img

def scaled_size(size, geom):
    aspect = fractions.Fraction(*size)
    wanted_aspect = fractions.Fraction(*geom)
    w, h = geom
    if aspect < wanted_aspect:
        w = int(h * aspect)     # black bars left and right
    else:
        h = int(w / aspect)     # black bars up and down
    return w, h

def letterbox(img, geom):
    """Fit the image into a letterbox of size GEOM."""
    fitsize = scaled_size(img.size, geom)
    if fitsize != img.size:
        img = img.resize(fitsize, PIL.Image.ANTIALIAS)
        if img.size != geom:
            full = PIL.Image.new(img.mode, geom)
            w, h = geom
            scaled_w, scaled_h = fitsize
            full.paste(img, ((w - scaled_w) / 2, (h - scaled_h) / 2))
            img = full
    return img

def process_pic(src, target, geom):
    if geom is None:
        os.symlink(os.path.abspath(src), target)
        return
    img = PIL.Image.open(src)
    img = apply_exif_orientation(img)
    img = letterbox(img, geom)
    img.save(target, 'JPEG', quality=90)

def generate_pics(pics, geom, picdir):
    if geom is not None:
        print 'scaling %d images...' % len(pics),
        sys.stdout.flush()
    for cnt, pic in enumerate(pics, 1):
        if geom is not None:
            print cnt,
            sys.stdout.flush()
        newfile = os.path.join(picdir, 'pic-%d.jpg' % cnt)
        process_pic(pic, newfile, geom)
        yield newfile
    if geom is not None:
        print

def create_images(pics, geom, frames, picdir):
    framesperpic = fractions.Fraction(frames, len(pics))
    startframe = 0
    for pic in generate_pics(pics, geom, picdir):
        for frame in xrange(int(startframe),
                            int(startframe + framesperpic)):
            os.symlink(pic, os.path.join(picdir, 'frame%d.jpg' % frame))
        startframe += framesperpic

def encode(mp3, outfile, picdir):
    subprocess.call(["ffmpeg",
                     "-r", str(FRAMES_PER_SEC),
                     "-i", os.path.join(picdir, 'frame%d.jpg'),
                     "-i", mp3,
                     #"-loglevel", "warning",
                     "-vcodec", "ffv1",
                     "-b:v", "500k",
                     "-acodec","copy",
                     outfile])

def determine_geometry(pics):
    sizes = [PIL.Image.open(pic).size for pic in pics]
    widths, heights = zip(*sizes)
    return max(widths), max(heights)

GEOM_RE = re.compile(r'(\d+)x(\d+)$')

def parse_geometry(s):
    match = GEOM_RE.match(s)
    if not match:
        raise ValueError("invalid geometry %r" % s)
    return (int(match.group(1)), int(match.group(2)))

def main():
    parser = optparse.OptionParser(usage="%prog [-s] [o OUTFILE] MP3 IMAGE...")
    parser.add_option('-g', '--geom', dest='geom',
                      metavar='wxh|auto|none',
                      help='desired image geometry, defaults to 640x480')
    parser.add_option('-s', '--shuffle', dest='shuffle',
                      default=False, action='store_true',
                      help='shuffle images before encoding')
    parser.add_option('-o', '--output', dest='output',
                      help='output file name, defaults to out.avi')
    options, args = parser.parse_args()
    if len(args) < 2:
        parser.print_usage(sys.stderr)
        sys.exit(2)
    mp3 = args[0]
    pics = args[1:]
    if options.shuffle:
        random.shuffle(pics)
    if options.geom is None:
        geom = DEFAULT_GEOMETRY
    elif options.geom == 'auto':
        geom = determine_geometry(pics)
    elif options.geom == 'none':
        geom = None
    else:
        geom = parse_geometry(options.geom)
    print 'using geometry', geom
    process(pics, mp3, geom, options.output or DEFAULT_OUTPUT_FILE)

if __name__ == '__main__':
    main()
